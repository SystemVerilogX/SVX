/*
Copyright (c) 2014, Intel Corporation

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Intel Corporation nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

package svx.parse;

import svx.Main;
import svx.behavioral.*;
import svx.behavioral.range.*;
import svx.config.IdentifierType;
import svx.parse.identifier.Identifier;
import svx.parse.identifier.ParseElement;
import svx.parse.identifier.ParseMnemonic;
import svx.parse.ParseSource;
import svx.utilities.Severity;

import java.io.*;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

import javax.naming.Context;


/**
 * SourceFile class is very top class of the SVX preprocessor.
 * SourceFile acts as the top ParseBranch of the ParseBranch/ParseNode tree, and is the class
 * which calls on the scanFile() method which generates this structure.
 * SourceFile contains the LogicalBranch/LogicalNode tree which is generated by its createLogicalStructures()
 * method. SourceFile is also used for creating and maintaining the out System Verilog files and the Errors and Warning log file.
 * 
 * 
 * @author ypyatnyc
 *
 */
public class SourceFile extends ParseSource
{
	private String sv_file_extension;

	private ParseContext file_context;  // A context for the file with no known position.
	
	/**
	 * The primary associated GeneratedSvFile.
	 */
	private GeneratedSvFile main_generated_file = null;
	private Hashtable<String, GeneratedSvFile> other_generated_files = new Hashtable<String, GeneratedSvFile>();
	
	/**
	 * Scanner class is used for scanning in the strings from the source SVX file
	 */
	protected Scanner input;
	
	/**
	 * Is a constant used to determine how tab characters should be interpreted when used in indentation
	 */
	private int SPACES_PER_TAB_RATIO = 4;
	
	private FileWriter fstreamSV;
	private BufferedWriter sv_writer;
	
	private FileWriter fstreamErrors;
	private BufferedWriter errors_writer;

	
	// Modes
	private boolean alignment_required = true;  // True if the translated SV code must remain line-for-line aligned with the SVX source code.
	
	
	/**
	 * A top-level LogicalBehHier container for this file.
	 */
	public LogicalBehHier topBehHier;
	
	private Hashtable <String, LogicalPipeline> logicalPipelines;  // TODO: Should we get rid of this global notion of pipelines, in favor of the hierarchy.  I think so.  (Hoover)
	//- private Hashtable <String, LogicalBehHier> logicalHiers;

	
	
    /**
     * Gated clocks generated in this file, indexed by SV clock signal
     * name; contents are SV code to generate the clock.
     *
	public Hashtable <String, String> clocks = new Hashtable <String, String>();
	*/
	
	/**
	 * Creates a new SourceFile.
	 * 
	 * @param in_file: Source .vx file.
	 * @param out_file: Output .vs file (the directly converted one);
	 */
	public SourceFile(File in_file, File sv_file)
	{
		super(in_file);
		
		file_context = new ParseContext().set(this, -1, -1);
		
		source_file = in_file;
		setType(NodeType.FILE);
		
		logicalPipelines = new Hashtable <String, LogicalPipeline>();
		
		
		// Create translated SV file.
		sv_file_extension = getFileExtension(sv_file.getName());
		if (sv_file_extension == null)
		{
			System.err.println("No file extension found on SV file name: " + sv_file.getName());
			System.exit(1);
		}
		
		// Create main generated file.
		main_generated_file = new GeneratedSvFile(null, derivedFileName(sv_file.toString(), "gen"), this);

		//prepares the source file for reading/scanning
		
		//prepares output files
		try 
		{	
			fstreamSV = new FileWriter(sv_file); //new FileWriter(filePath + fileName + ".vs");
			sv_writer = new BufferedWriter(fstreamSV);
			
			// TODO: Eliminate this file.
			fstreamErrors = new FileWriter(stripFileExtension(sv_file.toString()) + "_errorLog.txt");
			errors_writer = new BufferedWriter(fstreamErrors);
			
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		
		//if(!fileExtension.equals("vx"))
		//	printError("Warning: The input source file does not have a correct extension.");
		
		try 
		{
			input = new Scanner(source_file);
		} 
		catch (FileNotFoundException e) 
		{
			System.err.println("Error: The input source file could not be opened");
			e.printStackTrace();
			System.exit(1);
		}
	}
	
	/**
	 * @param file_name
	 * @return the index of the '.' for the file extension, or -1 if none.
	 */
	static public int indexOfExtension(String file_name)
	{
		int i = file_name.length();
		char ch;
		while (i > 1)
		{
			i--;
			ch = file_name.charAt(i);
			if (ch == '.') return i;
			if ((ch == '\\') || (ch == '/') || (i == 0)) return -1;
		};
        return -1;
	}
	
	/**
	 * @param file_name
	 * @return The file extension of the filename.
	 */
	static public String getFileExtension(String file_name)
	{
		int i = indexOfExtension(file_name);
		return (i < 0) ? null : file_name.substring(i+1);
	}
	
	/**
	 * @param file_name
	 * @return The basename of the given file name with the extension stripped.
	 */
	static public String stripFileExtension(String file_name)
	{
		int i = indexOfExtension(file_name);
		return (i < 0) ? file_name : file_name.substring(0, i);
	}
	
	/**
	 * For file name: "file_name.ext", and suffix: "suffix", returns "file_name_suffix.ext".  Null pointer exception if no file extension.
	 * @param file_name
	 * @param suffix
	 * @return New file name.
	 */
	static public String derivedFileName(String file_name, String suffix)
	{
		return (stripFileExtension(file_name) + "_" + suffix + "." + getFileExtension(file_name));
	}
	
	public File getSvxFile()
	{
		return source_file;
	}
	
	public String getSvFileExtension()
	{
		return sv_file_extension;
	}
	
	public GeneratedSvFile getGeneratedSvFile(String label)
	{
		return ((label == null || label.equals("")) ? main_generated_file : other_generated_files.get(label));
	}
	
	public boolean getAlignmentRequired()
	{
		return alignment_required;
	}
	

	/**
	 * Returns a logicalPipeline nested directly within the SourceFile.
	 * label String is used to key into logicalPipelines Hashtable for retrieving 
	 * a specified LogicalPipeline.
	 * 
	 * @param label used to identify the requested logicalPipeline
	 * 
	 * @return existing LogicalPipeline with the specified label
	 */
	public LogicalPipeline getLogicalPipeline(String label)
	{
		return logicalPipelines.get(label);
	}
	
	public ParseContext getFileContext()
	{
		return file_context;
	}
	
	/**
	 * This method is used to process a string containing a path to a file.
	 * It breaks the string down into two separate strings; one for the path and the other for the name.
	 * The string also checks the extension of the file to make sure it .vx file
	 * 
	 * @param file_name the full file name, containing the path and file extensions
	 * 
	 */
	/*
	private void produceSourceName(String file_name)
	{
		String tempName = "";
		int locationEndIndex = -1;
		
		for(int i = 0; i < file_name.length(); i++)
		{
			if(file_name.charAt(i) == '\\' ||
			   file_name.charAt(i) == '/')
			{
				tempName = "";
				locationEndIndex = i;
			}
			else if(file_name.charAt(i) == '.')
			{
				fileName = tempName;
				fileExtension = file_name.substring(i+1);
			}
			else
			{
				tempName += String.valueOf(file_name.charAt(i));
			}
		}
		
		filePath =  file_name.substring(0, locationEndIndex+1);
	}
	*/
	
	/**
	 * Returns the string containing the name of the source file
	 * 
	 * @return name of the source file
	 */
	/*
	public String getFileName()
	{
		return fileName;
	}
	*/
	
	/**
	 * Returns the string containing the source file's destination path
	 * 
	 * @return string containing the source file's destination path
	 */
	/*
	public String getFilePath()
	{
		return filePath;
	}
	*/
	
	
	/*
	 * The end method must be used at the end of the compile process.
	 * This methods "closes" the output files, preventing anymore data from
	 * being written to them
	 */
	
	/**
	 * This method must be used at the end of the preprocessor flow to "close()" all the generated
	 * files. 
	 */
	public void end()
	{
		try 
		{
			sv_writer.close();
			main_generated_file.close();
			errors_writer.close();
		} 
		catch (IOException e) 
		{
			e.printStackTrace();
		}
		
	}
	
	/**
	 * This method is used for printing a string to the generated declarations SV file. 
	 * 
	 * @param line string to be printed on a new line in the declarations SV file
	 */
	public void printlnSVdeclaration(String line)
	{
		getGeneratedSvFile(null).println(line);
	}
	
	private String staging_str = "";
	private String staging_indentation_str = "";
	/**
	 * Provide staging output for the declarations file.
	 * Text gets accumulated and output at the end.
	 * @param line
	 */
	public void printlnSVstaging(String line)
	{
		staging_str += Main.indentNonBlank(staging_indentation_str, line + "\n");
		if (Main.command_line_options.verbosity() > 2)
		{
			System.out.print(Main.indentString("STG  |" + staging_indentation_str, line + "\n"));
		}
	}
	
	public void indentStaging()
	{
		staging_indentation_str += "   ";
	}
	
	public void unindentStaging()
	{
		staging_indentation_str = staging_indentation_str.substring(0, staging_indentation_str.length() - 3);
	}
	
	/**
	 * Call after all print SVstaging calls have been made to output accumulated staging to declarations file.
	 */
	public void doneStaging()
	{
		printlnSVdeclaration(staging_str);
	}
		
	
	// TODO: Should this also go to System.err?  Make error reporting consistent.
    public void printError(String message)
    {
		try 
		{
			// Replace '\n' w/ new line, which is platform-dependent.
			for(int i = 0; i < message.length(); i++)
			{
				if(message.charAt(i) == '\n')
					errors_writer.newLine();
				else
					errors_writer.write(message.charAt(i));
			}
			
			errors_writer.newLine();
		    errors_writer.flush();	
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		//System.exit(2);
    }	
    	
    /**
    }
	 * This method is used for printing a string to the generated Errors and Warnings file. 
	 * 
	 * @param line string to be printed on a new line in the Errors and Warnings file
	 */
	public void printError(String message, ParseSource.FileLine line_num)
	{
		message = "Error in file " + source_file.toString() + ", line " + line_num + ": " + message;

		printError(message);
	}
	
	public void printSVline(String line)
	{
		// Output previous line.
		try 
		{
			// TODO: Is this the right plan for new lines across platforms?
			for(int i = 0; i < line.length(); i++)
			{
				if(line.charAt(i) == '\n')
				{
					sv_writer.newLine();
				}
				else
					sv_writer.write(line.charAt(i));
			}
			
			sv_writer.newLine();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		if (Main.command_line_options.verbosity() > 2)
		{
			System.out.print(Main.indentString("SV   |", line + "\n"));
		}
	}
	
	/**
	 * This method is used for printing a string to the line-for-line generated system verilog file. 
	 * 
	 * @param new_line string to be printed on a new line in the line-for-line generated SV file.
	 */
	public void nextSVline(String new_line)
	{
		// Print the last line, and capture this one.
		if (last_sv_line != null)
		{
			printSVline(last_sv_line);
		}
		last_sv_line = new_line;
	}
	
	//
	// Genvars
	//
	
    private TreeSet<String> genvars = new TreeSet<String>();
    
    public void requireGenvar(String genvar)
    {
    	genvars.add(genvar);
    }
    
    /**
     * @return An SV string representing the genvars declaration, with no carriage returns.  "" if no genvars.
     *         Eg: "genvars a, b, c;"
     */
    public String getGenvarString()
    {
    	String ret = "";
    	if (!genvars.isEmpty())
    	{
    		ret = "genvar ";
    		for (String genvar: genvars)
    		{
    			ret += genvar + ", ";
    		}
    		ret = ret.substring(0, ret.length() - 2);  // Strip the final ", ";
    		ret += ";";
    	}
    	
    	return ret;
    }
	

	
	
	
	// TODO: Eliminate this:
	/**
	 * Checks if a LogicalPipeline identified by the parsePipeline parameter already exists within logicalPipelines Hashtable.
	 * If it exists, the identifier is added to the LogicalPipeline, and the identified LogicalPipeline object is returned by the method.
	 * If there is no LogicalPipeline in the hashtable which matches the identifier of the parsePipeline, this method creates a new
	 * LogicalPipeline object and uses it to populate the logicalPipelines hashtable.
	 * 
	 * @param parsePipeline ParsePipeline object used to generate or modify its associated LogicalPipeline
	 * 
	 * @return LogicalPipeline that is associated with the input ParsePipeline
	 */
	public LogicalPipeline addPipeline(ParsePipeline parsePipeline)
	{
		ParseMnemonic temp_identifier = parsePipeline.produceMnemonic(Prefix.PIPELINE);
		LogicalPipeline temp_logicalNode = logicalPipelines.get(temp_identifier.getLabel());
		
		if(temp_logicalNode == null)
		{
			temp_logicalNode = new LogicalPipeline(temp_identifier);
			temp_identifier.setLogicalNode(temp_logicalNode);
			logicalPipelines.put(temp_identifier.getLabel(), temp_logicalNode);
		}
		else
		{
			
			temp_identifier.setLogicalNode(temp_logicalNode);
			temp_logicalNode.addIdentifier(temp_identifier);
		}
		
		return logicalPipelines.get(temp_identifier.getLabel());
	}
	
	/**
	 * This method parses the source .vx file and generates the parse tree of ParseBranch/ParseNodes.
	 */
	public void parseFile()
	{
		ActiveParseContext context = ActiveParseContext.get();
		ParseNode prev_node = null;
		ParseNode this_node = null;
		ParseNode next_node = null;
		
		prev_node = new ParseNode();
		this_node = new ParseNode();
		this_node.setType(NodeType.SV);
		
		boolean wasWithinCommentContext = false;
		boolean isWithinCommentContext = false;
		
		//flag used for identifying if parsing inside always_comb block.
		boolean acbComplete = true;
		boolean svxPlusComplete = true;
		
		
		//commentComplete is set to false, when this method is parsing inside of a comment block /* -> */
		boolean commentComplete = true;
		
		//macroComplete is set to false, when this method is parsing inside of a macro declaration
		boolean macroComplete = true;
		int macroParentheses = 0;
		
		
		//assignmentComplete is set to false, when this method is parsing inside of typical assignment
		//and will only return to true at a terminating ';'
		boolean assignmentComplete = true;
		
		boolean eof_flag = false;
		
		boolean getNextNode = true;
		
		int totalLineCount = 0;

		
		ParseBranch parent = this;  // The parent branch of the next node to parse.  (Note that SourceFile has a 'parent' as well (which is null and uninteresting.)
		while(!eof_flag)
		{
			if(input.hasNext())
			{
				if(getNextNode){
					next_node = new ParseNode(input.nextLine());
					context.set(next_node, 0, -1);  // TODO: Improve
				
					totalLineCount++;
				
					ParseNode.processIndentation(context, SPACES_PER_TAB_RATIO);
				
					//checks for empty line
					if(next_node.stringWithoutIndentation.length() == 0){
						this_node.appendNode(next_node);
						continue;
					}

					
					/*
					 * checks for comment context, and possible change in comment context
					 */
					if(		isWithinCommentContext 
						|| 	next_node.stringWithoutIndentation.regionMatches(0, "//", 0, 2)
						|| 	next_node.stringWithoutIndentation.regionMatches(0, "/*", 0, 2)){
						
						isWithinCommentContext = next_node.scan_for_comments(isWithinCommentContext);
						this_node.appendNode(next_node);
						continue;
					}
					else{
						isWithinCommentContext = next_node.scan_for_comments(isWithinCommentContext);
					}
					
				}else
					getNextNode = true;
				
				char first_char = next_node.getStringWithoutIndentation().charAt(0);
				Identifier node_ident = null;
				if(!acbComplete)
				{
					if(next_node.getIndentation() <= this_node.getIndentation())
					{
						acbComplete = true;
						//to prevent overriding next_node
						getNextNode = false;
						continue;
					}
					else
					{
						this_node.appendNode(next_node);
					}
					continue;
				}
				
				if(!svxPlusComplete)
				{
					if(next_node.getIndentation() <= this_node.getIndentation())
					{
						svxPlusComplete = true;
						getNextNode = false;
					}
					else
					{
						this_node.appendNode(next_node);
					}
					continue;
				}
				
				//this line contains continuation of a signal assignment
				else if(!assignmentComplete)
				{
					for(int i = 0; i < next_node.stringWithoutIndentation.length(); i++)
					{
						if(next_node.stringWithoutIndentation.charAt(i) == ';')
						{
							assignmentComplete = true;
							break;
						}
						else if(next_node.stringWithoutIndentation.charAt(i) == '=')
						{
							this_node.setType(NodeType.ASSIGNMENT);
						}
					}
					
					this_node.appendNode(next_node);
					continue;
				}
				else if(!macroComplete)
				{
					for(int i = 0; i < next_node.stringWithoutIndentation.length(); i++)
					{
						if(next_node.stringWithoutIndentation.charAt(i) == '(')
						{
							macroParentheses++;
						}
						else if(next_node.stringWithoutIndentation.charAt(i) == ')')
						{
							macroParentheses--;
						}
					}
					
					if(macroParentheses == 0)
					{
						macroComplete = true;
					}
					
					this_node.appendNode(next_node);
					continue;
				}
				else if(next_node.stringWithoutIndentation.regionMatches(false, 0, ParseSVXVersion.mnemonicStr, 0, 12))
				{
					next_node.setType(NodeType.SVX_VERSION);
				}
				else if(this_node.getType() == NodeType.SV)
				{
					if(next_node.stringWithoutIndentation.regionMatches(false, 0, "\\SVX", 0, 4))
					{
						next_node.setType(NodeType.SVX);
					}
					else if(next_node.stringWithoutIndentation.regionMatches(false, 0, "\\SV_plus", 0, 8))
					{
						next_node.setType(NodeType.SV_PLUS_UNSCOPED);
					}
					else
					{
						this_node.appendNode(next_node);
						continue;	
					}
				}
				else if(this_node.getType() == NodeType.SV_PLUS_UNSCOPED)
				{
					if(next_node.stringWithoutIndentation.regionMatches(false, 0, "\\SVX", 0, 4))
					{
						next_node.setType(NodeType.SVX);
					}
					else if(next_node.stringWithoutIndentation.regionMatches(false, 0, "\\SV", 0, 3))
					{
						next_node.setType(NodeType.SV);
					}
					else
					{
						this_node.appendNode(next_node);
						continue;	
					}
				}
				else if(next_node.stringWithoutIndentation.regionMatches(false, 0, "\\SVX", 0, 4))
				{	
					next_node.setType(NodeType.SVX);
				}
				else if(next_node.stringWithoutIndentation.regionMatches(false, 0, "\\SV_plus", 0, 8))
				{	
					if(next_node.getIndentation() == 0)
						next_node.setType(NodeType.SV_PLUS_UNSCOPED);
					else{
						svxPlusComplete = false;
						next_node.setType(NodeType.SV_PLUS);
					}
				}
				else if(next_node.stringWithoutIndentation.regionMatches(false, 0, "\\SV", 0, 3))
				{
					next_node.setType(NodeType.SV);
				}
				//TODO: case sensitive
				else if(next_node.stringWithoutIndentation.regionMatches(false, 0, "\\always_comb", 0, 12))
				{	
					acbComplete = false;
					next_node.setType(NodeType.ALWAYS_COMB);
				}
				else if (first_char == '\t')
				{
					context.report(0, Severity.FATAL_ERROR, "TAB", "Tabs are not legal indentation.  (Line " + totalLineCount + ")");  // TODO: It would be nice to try to come up with a reasonable interpretation.
				}
				else if(next_node.stringWithoutIndentation.regionMatches(false, 0, "**", 0, 2))
				{
					//initially assume the parse node is a mere signal declaration
					next_node.setType(NodeType.SV_TYPE);
					
					assignmentComplete = false;
					
					for(int i = 1; i < next_node.stringWithoutIndentation.length(); i++)
					{					
						if(next_node.stringWithoutIndentation.charAt(i) == ';')
						{
							assignmentComplete = true;
							break;
						}
						else if(next_node.stringWithoutIndentation.charAt(i) == '=')
						{
							next_node.setType(NodeType.ASSIGNMENT);
						}
					}
				}
				// Assignments can start with:
				else if(first_char == '$' ||   // pipesig
						first_char == '*' ||   // SV sig
						first_char == '{' ||   // concat
						Character.isAlphabetic(first_char))  // labels and module instantiations
				{
					next_node.setType(NodeType.ASSIGNMENT);
					assignmentComplete = false;
					
					for(int i = 0; i < next_node.stringWithoutIndentation.length(); i++)
					{					
						if(next_node.stringWithoutIndentation.charAt(i) == ';')
						{
							assignmentComplete = true;
							break;
						}
					}	
				}
				else if(first_char == '`')
				{
					next_node.setType(NodeType.ASSIGNMENT);
					macroComplete = false;
					
					for(int i = 0; i < next_node.stringWithoutIndentation.length(); i++)
					{
						if(next_node.stringWithoutIndentation.charAt(i) == '(')
						{
							macroParentheses++;
						}
						else if(next_node.stringWithoutIndentation.charAt(i) == ')')
						{
							macroParentheses--;
						}
					}
					
					if(macroParentheses == 0)
					{
						macroComplete = true;
					}
				}
				else if(first_char == Prefix.PIPELINE.getChar())
				{
					next_node.setType(NodeType.PIPELINE);
				}
				else if(first_char == Prefix.STAGE.getChar())
				{
					next_node.setType(NodeType.STAGE);
				}
				else 
				{
					// Parse as an identifier node.
					node_ident = Identifier.parse(-1);
					IdentifierType ident_type = node_ident.getType();
					if(ident_type == IdentifierType.BEH_HIER)
					{
						next_node.setType(NodeType.BEH_HIER);
					}
					else if(ident_type.isWhen())
					{
						next_node.setType(NodeType.WHEN);
					}
					else if(ident_type.isAttribute())
					{
						next_node.setType(NodeType.ATTRIBUTE);
					}
					else if(node_ident == Identifier.source_keyword)
					{
						next_node.setType(NodeType.SOURCE);
					}
					else if(node_ident == Identifier.end_source_keyword)
					{
						next_node.setType(NodeType.END_SOURCE);
					}
					else
					{
						context.report(0, Severity.FATAL_ERROR, "NODE-TYPE", "Cannot determine node type.  (Line " + totalLineCount + ")");
						// TODO: Try to recover from this.
					}
				}
					
				context.set(prev_node, this_node.getString(), this_node.getIndentation(), -1 /* TODO: Keep track of line number in parsing as sanity check */);
				
				// First parse node types that may or may not be leaves.
				boolean node_processed = false;
				if(this_node.getType() == NodeType.BEH_HIER)
				{
					parent.addNode(new ParseBehHier(parent, this_node));
					node_processed = true;
				}
				if(next_node.getIndentation() <= this_node.getIndentation())
				{
					if (node_processed) {
					}
					else if(this_node.getType() == NodeType.ASSIGNMENT ||
					   this_node.getType() == NodeType.ALWAYS_COMB ||
					   this_node.getType() == NodeType.SV_PLUS_UNSCOPED ||
					   this_node.getType() == NodeType.SV_PLUS)
						 					
					{
						parent.addNode(new Assignment(parent, this_node));
					}
					else if(this_node.getType() == NodeType.SVX)
					{
						parent.addNode(new ParseSVX(parent, this_node));
					}
					else if(this_node.getType() == NodeType.SVX_VERSION)
					{
						parent.addNode(new ParseSVXVersion(parent, this_node));
					}
					else if(this_node.getType() == NodeType.SV)
					{
						if (this_node.numLines_self > 0)
							// To support badly-formatted files we start in \SV context.  This check avoids creating
							// the empty \SV node as the first node of a well-formatted file.
						{
							parent.addNode(new ParseSV(parent, this_node));
						}
					}
					else if(this_node.getType() == NodeType.SV_TYPE)
					{
						context.set(prev_node, this_node.getString(), this_node.getIndentation(), -1 /* TODO: Keep track of line number in parsing as sanity check */);
						parent.addNode(new ParseSvType(parent, this_node));
					}
					else if(this_node.getType() == NodeType.ATTRIBUTE)
					{
						parent.addNode(new ParseIdentifierNode(parent, this_node));
					}
					else if(this_node.getType() == NodeType.END_SOURCE)
					{
						parent.addNode(new ParseEndSource(parent, this_node));
					}
					else
					{
						ActiveParseContext.Report(0, Severity.ERROR, "INDENTATION", "Node shouldn't be a leaf.  (Line " + totalLineCount + ")");
					}
					
					// Back out of current indentation to that of the next line.
					// Update number of lines for each ancestor branch, and prepare parent based on indentation of next line.
					while(parent.getIndentation() >= next_node.getIndentation() && parent.getParent() != null)
					{
						parent.countChildLines(null);
						parent = parent.getParent();
					}
				}
				//if the next line has a greater level of indentation than this line
				//then this line must be a ParseBranch (contains children).
				else
				{
					if (next_node.getIndentation() != this_node.getIndentation() + 3)
					{
						ActiveParseContext.Report(0, Severity.ERROR, "INDENTATION", "Proper indentation is three spaces for each level.  (Line " + totalLineCount + ")");
					}
					if (node_processed) {
					}
					else if(this_node.getType() == NodeType.SVX)
					{
						parent.addNode(new ParseSVX(parent, this_node));
					}
					else if(this_node.getType() == NodeType.PIPELINE)
					{
						parent.addNode(new ParsePipeline(parent, this_node));
					}
					else if(this_node.getType() == NodeType.WHEN)
					{			
						parent.addNode(new ParseWhen(parent, this_node));
					}
					else if(this_node.getType() == NodeType.STAGE)
					{
						if(this_node.getParseBranch_ofType(NodeType.STAGE) == null)
							parent.addNode(new ParseStage(parent, this_node));
						else
							ActiveParseContext.Report(0, Severity.ERROR, "NESTED-STAGES", "Stage within a stage (should be caught again later).  (Line " + totalLineCount + ")");
					}
					else if(this_node.getType() == NodeType.SOURCE)
					{
						ParseSource new_node = new ParseSource(parent, this_node);
						new_node.parse(context);
						parent.addNode(new_node);
					}
					else
					{
						ActiveParseContext.Report(0, Severity.ERROR, "INDENTATION", "Indentation below a leaf node.  (Line " + totalLineCount + ")");
					}
					
                    try {
					    parent = (ParseBranch) parent.parseNodes.lastElement();  // TODO: "parent = (ParseBranch) prev_node;"?
                    } catch (ClassCastException e) {
                    	// parent was a leaf, not a ParseBranch.  Indentation below a leaf.
                    	// TODO: For now, we'll make this fatal, but it would be good to continue and avoid
                    	//       operations on the null parent.
						ActiveParseContext.Report(0, Severity.FATAL_ERROR, "INDENTATION", "Indentation below a leaf node.  (Line " + totalLineCount + ")");
                        parent = null;
                    }
				}
					
				// Next node.
				prev_node = new ParseNode(this_node);  // TODO: Just "prev_node = this_node;"?
				this_node = new ParseNode(next_node);  // TODO: Just "this_node = next_node;"?
			}
			else
			{
				// End of file.
				// TODO: Should use the main loop to do this.  Bad cut-n-paste.
				// Add this_node of correct type.
				// TODO: Make sure final parse node string ends in "\n".
				if(this_node.getType() == NodeType.SV)
				{
					parent.addNode(new ParseSV(parent, this_node));
				}
				else if(this_node.getType() == NodeType.SV_TYPE)
				{
					context.set(prev_node, this_node.getString(), this_node.getIndentation(), -1 /* TODO: Keep track of line number in parsing as sanity check */);
					parent.addNode(new ParseSvType(parent, this_node));
				}
				else if(!commentComplete)
				{
					parent.addNode(new ParseNode(parent, this_node));
				}
				else if(this_node.getType() == NodeType.ASSIGNMENT || this_node.getType() == NodeType.ALWAYS_COMB 
						|| this_node.getType() == NodeType.SV_PLUS_UNSCOPED || this_node.getType() == NodeType.SV_PLUS)
				{
					parent.addNode(new Assignment(parent, this_node));
				}

				// Update line counts for parent branches with the addition of this node?
				while(parent.getParent() != null)
				{	
					parent.countChildLines(null);
					parent = parent.getParent();
				}
				 
				eof_flag = true;
			}
			
			if (parent == null) Main.breakpoint();
			
		
		}//end while
		
		
		// Capture attribute flags.
		// TODO: No checking currently for unknown attributes.
		context.setNoStateSigs(getAttribute("no_state_sigs") != null);
		
	}//end scan_file
	
	
	/**
	 * This method is used to call the recursive createLogicalStrcture(ParseBranch parse_branch_, LogicalPipeline pipeline_, 
	 * LogicalWhen when_, LogicalStage stage_)
	 * 
	 * @see SourceFile#createLogicalStructure(ParseBranch, LogicalPipeline, LogicalWhen, LogicalStage)
	 */
	public void createLogicalStructure()
	{
		// Make sure the first node in this SourceFile is an SVX_VERSION.
		ParseNode firstNode = this.parseNodes.firstElement();
		if (firstNode == null || (firstNode.getType() != NodeType.SVX_VERSION))
		{
			ActiveParseContext.Report(0, Severity.WARNING, "FILE-HEADER", "First line of every SVX file must be (literally):\n\t\"" + ParseSVXVersion.requiredFileHeader +
					   "\", and it is not.");
		}
		
		topBehHier = new LogicalBehHier((ParseElement)null);
		//topBehHier.setRange(new Range(topBehHier, ""));

		ParseContext context = ActiveParseContext.get();

		// Top recursive call.
		createLogicalStructure(context, this, null, topBehHier, null, null, "");
		
		context.set(this, -1, -1);  // No longer parsing.  No context, except the file.
	}
	
	public void dumpSv()
	{
		ParseContext context = ActiveParseContext.get();
		
		// Top recursive call.
		dumpSv(context, this, "");
		
		context.set(this, -1, -1);  // No longer parsing.  No context, except the file.
		
		// Output the remaining line.
		printSVline(last_sv_line);
	}
	
	// TODO: Maintain ParseContext through this method.
	/**
	 * This method is used to recursively generate a LogicalBranch/LogicalNode structure from the ParseBranch/ParseNode tree.
	 * The method tracks its current position both on ParseBranch/ParseNode tree as well as on the LogicalBranch/LogicalNode
	 * structure that its generating. In addition to generating the Logical structure this method also converts the SVX source code
	 * and populates the line-for-line system verilog file.  It is responsible for printing last_sv_line and then populating it.
	 * 
	 * @param	parse_parent	ParseBranch who's children node will be processed and converted into LogicalNode
	 * @param	pipeline		LogicalPipeline that the parse_branch_ is currently scoped under
	 * @param   beh_scope      Lowest-level LogicalBehScope that the parse_branch_ is currently scoped under
	 * @param	when			LogicalWhen that the parse_branch_ is currently scoped under
	 * @param	stage			LogicalStage that the parse_branch_ is currently scoped under
	 * @param	end_required	The parse parent has a 'begin' in it's SV code that must be 'end'ed.
	 */
	private static String last_sv_line = null;  // This line is to be added to the SV code.  In some cases this line must be modified to terminate scope before we process the next line.
	private void createLogicalStructure(ParseContext context, final ParseBranch parse_parent, final LogicalPipeline pipeline, final LogicalBehScope beh_scope,
			final LogicalWhen when, final LogicalStage stage, String indentation_str)
	{
		ParseNode parse_child = null;
		
		boolean declarationsIncluded = false;
		
		for(int i = 0; i < parse_parent.parseNodes.size(); i++)
		{
			parse_child = parse_parent.parseNodes.get(i);
			context.set(parse_child, 0, -1);

			if(parse_child instanceof ParseBranch)
			{
				ParseBranch parse_child_branch = (ParseBranch) parse_child;
				//print `include of the declarations/latch/flop file at first occurrence of ParseSVX section
				String next_indentation_str = indentation_str + "   ";
				
				//Some ParseBranch objects(|, ?, >), contain identifiers which will be selectively commented out
				//TODO: investigate behavior of ParseBranches with many identifiers such as |pipe>inst
				Identifier identifier = parse_child_branch.getIdentifier();
				
				//if(identifier != null)
				//{
				//	parse_child.stringSV = parse_child.stringSV.replace(identifier.toString(), "/*" + identifier.toString() + "*/");
				//}
				
				String stringSVcore = "/*_" + parse_child.string.substring(parse_child.indentation, parse_child.getEndOfStringIndex()+1) + "_*/";
				String stringSVend = parse_child.string.substring(parse_child.getEndOfStringIndex()+1);
				
				if(parse_child.getType() == NodeType.SVX)
				{
					if(!declarationsIncluded){
						parse_child.stringSV = indentation_str + "`include \"" + main_generated_file.file.getName() + "\"" +
								// SV parsers don't like stuff after include file, so can't do this:  + "  " + stringSVcore +
								stringSVend;
		
						if (Main.command_line_options.bestSv()){
							parse_child.stringSV += "\ngenerate";
						}
						
					} else {
						parse_child.stringSV = indentation_str + stringSVcore + " generate " + stringSVend;
					}
					
					declarationsIncluded = true;
					
					parse_child.sv_end_scope_str = "endgenerate";
					 	// TODO: Would be nice to drop "endgenerate" in place of the \SV line which must be coming up next (or end of file).
					    //       But this will require a different method than endSVscope(..) since endSVscope(..) would insert at the end of
					    //       of the SV block.

					// Recurse
					createLogicalStructure(context, parse_child_branch, pipeline, beh_scope, when, stage, next_indentation_str);
				}
				else if(parse_child.getType() == NodeType.BEH_HIER ||
						parse_child.getType() == NodeType.PIPELINE)
				{					
					// Add this beh scope to parent.
					LogicalBehScope current_logicalBehScope = beh_scope.processParseChildScope((ParseBehScope)parse_child_branch);
					parse_child_branch.setCorrespondingLogicalBranch(current_logicalBehScope);
					
					//String stringSV = current_logicalBehScope.getSVString();  // TODO: This needs to match the number of .vs lines.  I think there can be multiple lines if there's a comment.
					String stringSV_temp = current_logicalBehScope.getSVString();
					
					if ((stringSV_temp == null) || (stringSV_temp.equals("")))
					{
						parse_child.stringSV = indentation_str + stringSVcore + stringSVend;   // TODO: Move into ParseNode.SVstring.
					} else
					{
						// stringSV is a for loop w/ a 'begin'.  We need an 'end' later.
						parse_child.stringSV = indentation_str + stringSV_temp + "  " + stringSVcore + stringSVend;
						parse_child.sv_end_scope_str = "end";
					}
					
					// Recurse
					// Prevent pipeline nesting
					LogicalPipeline current_pipeline = pipeline;
					
					if(parse_child.getType() == NodeType.PIPELINE)
					{
						if(pipeline == null)
						{
							current_pipeline = (LogicalPipeline)current_logicalBehScope;
						}
						else //current_logicalBehScope is a nested pipeline
						{
							ActiveParseContext.Report(0, Severity.FATAL_ERROR, "NESTED-PIPE", "May not nest pipeline \"" + current_logicalBehScope.toString() + "\" under another pipeline \"" + pipeline.toString() + ".");
						}
					}
					
					// Associate stage with this beh scope.
					if (stage != null)
					{
						//...current_logicalBehScope.addStage((ParseStage)parse_child);
					}
					
					// Associate when with this beh scope???
					//...
						
//					createLogicalStructure(	parse_child_branch, (parse_child.getType() == NodeType.PIPELINE) ? (LogicalPipeline)current_logicalBehScope : pipeline,
//											current_logicalBehScope, when, stage, next_indentation_str);
					createLogicalStructure(context, parse_child_branch, current_pipeline, current_logicalBehScope, when, stage, next_indentation_str);
				}
				else if(parse_child.getType() == NodeType.WHEN)
				{
					LogicalWhen current_logicalWhen = null;
					if(pipeline == null)
					{
						ActiveParseContext.Report(0, Severity.FATAL_ERROR, "NO-PIPE", "Pipeline not found for when declaration.");
					}
					else if(when != null)
					{
						ActiveParseContext.Report(0, Severity.FATAL_ERROR, "NESTED-WHEN", "Nested When's are not currently permitted.");
						current_logicalWhen = when.addParseWhen((ParseWhen)parse_child, beh_scope);  // TODO: Doesn't look right.
					}
					else
					{
						// TODO: Don't we need to look for an existing definition for this when?
						current_logicalWhen = beh_scope.addWhen((ParseWhen)parse_child);
					}
					parse_child_branch.setCorrespondingLogicalBranch(current_logicalWhen);
					
					//-beh_scope.addWhenSignal(current_logicalWhen);
					
					parse_child.stringSV = indentation_str + stringSVcore + stringSVend;
					//nextSVline(indentation_str + parse_child.stringSV);//parse_child.stringWithoutIndentation);
					
					// Recurse
					createLogicalStructure(context, parse_child_branch, pipeline, beh_scope,
							current_logicalWhen, stage, next_indentation_str);
				}
				else if(parse_child.getType() == NodeType.STAGE)
				{
					ParseStage parse_stage = (ParseStage)parse_child;
					if(stage != null)
					{
						ActiveParseContext.Report(0, Severity.FATAL_ERROR, "NESTED-STAGES", "Nested stages.");
					}
					LogicalStage current_logicalStage = stage;
					if(pipeline == null)
					{
						ActiveParseContext.Report(0, Severity.FATAL_ERROR, "NO-PIPE", "Pipeline not found for stage declaration.");
					}
					else if(when != null)
					{
						current_logicalStage = when.addStage(parse_stage);
					}
					else
					{
						current_logicalStage = beh_scope.addStage(parse_stage);
					}
					parse_child_branch.setCorrespondingLogicalBranch(current_logicalStage);
					if (parse_stage.getLogicalParent() == null) {Main.breakpoint();}
					
					parse_stage.stringSV = indentation_str + stringSVcore + stringSVend;
					//nextSVline(indentation_str + "//" + parse_child.stringSV); //parse_child.stringWithoutIndentation);

					// Recurse
					createLogicalStructure(context, parse_child_branch, pipeline, beh_scope,
							when, current_logicalStage, next_indentation_str);
				}
				else if(parse_child.getType() == NodeType.SOURCE)
				{
					parse_child.stringSV = indentation_str + "// " + parse_child.stringWithoutIndentation;
					// This scope has no impact no impact on logical structure.  Just recurse.
					createLogicalStructure(context, parse_child_branch, pipeline, beh_scope, when, stage, next_indentation_str);
				}
				else
				{
					context.report(0, Severity.BUG, "BUG", "Unrecognized parse branch type.");
				}
			}
			else if(parse_child.getType() == NodeType.ASSIGNMENT || parse_child.getType() == NodeType.ALWAYS_COMB 
					|| parse_child.getType() == NodeType.SV_PLUS || parse_child.getType() == NodeType.SV_PLUS_UNSCOPED)
			{
				// Checking.
				if (pipeline == null) context.report(0, Severity.FATAL_ERROR, "NO-PIPE", "Assignment statement requires pipeline scope.");
				if (stage == null)    context.report(0, Severity.FATAL_ERROR, "NO-STAGE", "Assignment statement requires stage.");
				
				parse_child.stringSV = "";
				((Assignment)parse_child).parse2(context, '\0', 0);
				if (parse_child.getType() == NodeType.ALWAYS_COMB)
				{
					parse_child.sv_end_scope_str = "end";					
				}
			}
			else if(parse_child.getType() == NodeType.SV ||
					parse_child.getType() == NodeType.SVX_VERSION)
			{
			}
			else if(parse_child.getType() == NodeType.SV_TYPE)
			{
				if(beh_scope != null)
				{
					beh_scope.addStruct((ParseSvType)parse_child);
				}
				else if(pipeline != null)
				{
					Main.breakpoint();  // Is it possible to get here?
					pipeline.addStruct((ParseSvType)parse_child);
				}
				else
				{
					context.report(0, Severity.BUG, "BUG", "SV type is missing scope.");
				}
				parse_child.stringSV = "";
			}
			else if(parse_child.getType() == NodeType.ATTRIBUTE ||
					parse_child.getType() == NodeType.END_SOURCE)
			{
				// Do nothing, just let the attribute sit there.
				parse_child.stringSV = indentation_str + "// " + parse_child.stringWithoutIndentation;
			}
			else
			{
				ActiveParseContext.Report(0, Severity.FATAL_ERROR, "PARSE", "Unrecognizable ParseNode.");
			}				
		}
	}
		
	private void dumpSv(ParseContext context, final ParseBranch parse_parent, String indentation_str)
	{
		ParseNode parse_child = null;
		
		for(int i = 0; i < parse_parent.parseNodes.size(); i++)
		{
			parse_child = parse_parent.parseNodes.get(i);
			context.set(parse_child, 0, -1);			

			nextSVline(parse_child.stringSV);
			// TODO: We can add checking (in one place) that we are
			//       producing as many .vs lines as .vx lines.
			if(parse_child instanceof ParseBranch)
			{
				ParseBranch parse_child_branch = (ParseBranch) parse_child;
				
				// Recurse
				dumpSv(context, parse_child_branch, indentation_str + "   ");
			}

			last_sv_line = parse_child.endSVscope(indentation_str, last_sv_line, parse_child.sv_end_scope_str);					
		}
	}
	
	
	private void printSvScopeComment(final LogicalBehScope scope, String scope_str, boolean decl)
	{
		if (!scope.isTop())
		{
			// TODO: Currently, scope.getIdentifier() can be null.  This will change, and the condition below can be deleted.
			scope_str += (scope.getIdentifier() == null) ? scope.getLabel()
					                                     : scope.getIdentifier().toString();
			scope_str += ((scope.getRange() == null) ? "" : (scope.getRange().toString()));
			String scope_comment = "\n//\n// Scope: " + scope_str + "\n//\n";
			if (decl)
			{
				printlnSVdeclaration(scope_comment);
			}
			printlnSVstaging(scope_comment);
		}
	}
	
	/**
	 * @param scope
	 * @return SV line (w/ no preceeding whitespace or ending carriage return) for the forloop, and register the need for the corresponding genvar.
	 */
	public String loopBeginStr(final LogicalBehScope scope)
	{
		Range range = scope.getRange();
		if (Range.numArgs(range) == 2)
		{
			String var = scope.getSvLoopVar();  // getInstanceVar();
			// TODO: What if range bounds expressions cannot be evaluated to an integer?
			requireGenvar(var);
            return "for (" + var + " = " + range.getStartBitIndex().getLabel() + "; " + var + " <= " + range.getEndBitIndex().getLabel() + "; " + var + "++) begin";
			//return "for (" + var + " = " + Integer.toString(scope.getRange().getStartBitIndex().getValue()) + "; " +
			//       var + " < " + Integer.toString(scope.getRange().getEndBitIndex().getValue() + 1) + "; " +
			//       var + "++) begin";
		} else
		{
			return "";
		}
	}

	private String loopEndStr(final LogicalBehScope scope)
	{
		return (scope.getRange() != null) ? "end" : "";
	}
	
	public void printFlopsAndLatches(PipeSignal sig)
	{
		if (sig.getIdentifier().getType().isStagedSig())
		{
			printlnSVdeclaration("// For signal \"" + sig.getLabel() + "\"");
			printlnSVstaging("// For signal \"" + sig.getLabel() + "\"");
		
			sig.declareStaging();  // Declares staging and signal declarations for this sig.
		
			printlnSVdeclaration("");
			printlnSVstaging("");
		}
    }

	/**
	 * This method traverses the behavioral hierarchy recursively and for each signal,
	 * generates all node declarations and staging elements that are necessary for
	 * that signal's assignments and uses.
	 */
	public void generateSvRecursive(final LogicalBehScope scope, String scope_str)
	{
		// Process signals at this scope.
		//
			
		// SV comment for this scope.
		printSvScopeComment(scope, scope_str, true);
		
		// Loop over instances in this scope in staging.
		printlnSVstaging(loopBeginStr(scope));
		
		if (scope.getSignals() != null)
		{
			//TODO: Replace Hashtable with another construct that inherently sorts by key and eliminate array sort.
			// Sort.
			Identifier[] signal_keys = (Identifier[]) scope.getSignals().keySet().toArray(new Identifier[0]);  
	        Arrays.sort(signal_keys);
	       
	        for(Identifier key : signal_keys) {
	        	PipeSignal sig = scope.getSignals().get(key);
	        	if(!sig.isEmpty())
				{
					printFlopsAndLatches(sig);
				}
	        }
		}
			
		// Clock signal declarations.
	
	    if (!scope.clocks.isEmpty())
	    {
	        // Print clocks at this scope.
	
			printlnSVdeclaration("// Clock signals.");
		    for (Clock clk: scope.clocks.values())
		    {
		        printlnSVdeclaration(clk.declareClockStr());
		    }
	    }


		//TODO: Replace Hashtable with another construct that inherently sorts by key and eliminate array sort.
		// Sort and recurse into children.
		String[] scope_keys = (String[]) scope.children.keySet().toArray(new String[0]);  
		Arrays.sort(scope_keys);

		for(String key : scope_keys) {
			indentStaging();
			LogicalBehScope child_scope = scope.children.get(key);
			generateSvRecursive(child_scope, scope_str);
			unindentStaging();
		}
		
		printlnSVstaging(loopEndStr(scope));
	}
	
	
	public void generateSv()
	{
		// Output genvar declarations.
		printlnSVdeclaration(getGenvarString());
		printlnSVdeclaration("");

		printlnSVstaging("\ngenerate\n");
		generateSvRecursive(topBehHier, "");
		printlnSVstaging("\nendgenerate\n");
	}


	
	// TODO: It would probably be better to buffer this as we iterate for staging.  Could create a class for the current staging_str and use another instance of that for clocks.
	/**
	 * This method traverses the behavioral hierarchy recursively to generate clocks. 
	 */
	private void generateSvClocksRecursive(final LogicalBehScope scope, String scope_str)
	{
		// SV comment for this scope.
		printSvScopeComment(scope, scope_str, false);
		
		// Loop over instances in this scope in staging.
		printlnSVstaging(loopBeginStr(scope));

		// Print clocks at this scope.
        for (Clock clk: scope.clocks.values())
        {
        	printlnSVstaging(clk.makeClockStr());
        }

	//TODO: Replace Hashtable with another construct that inherently sorts by key and eliminate array sort.
        // Sort and recurse into children.
        String[] scope_keys = (String[]) scope.children.keySet().toArray(new String[0]);  
		Arrays.sort(scope_keys);

		for(String key : scope_keys) {
			indentStaging();
			LogicalBehScope child_scope = scope.children.get(key);
			generateSvClocksRecursive(child_scope, scope_str);
			unindentStaging();
		}
		
		printlnSVstaging(loopEndStr(scope));
	}


	private void generateSvClocks()
	{
		// Output the clock generation.
		printlnSVstaging("");
		printlnSVstaging("");
		printlnSVstaging("//");
		printlnSVstaging("// Gated clocks.");
		printlnSVstaging("//");
		printlnSVstaging("");
		printlnSVstaging("generate");
		printlnSVstaging("");

		generateSvClocksRecursive(topBehHier, "");

		printlnSVstaging("");
		printlnSVstaging("endgenerate");
		printlnSVstaging("");
	}
	
	/**
	 * The main routine to pre-process the file after construction.
	 */
	public void process()
	{
		// Determine modes.
		alignment_required = !Main.command_line_options.bestSv();
		
		
		//parses the source file and generates the ParseHier/ParseNode tree
		parseFile();
		
		//processes the ParseHier/ParseNode tree and generates the behavioral structure.
		// TODO: Need to separate out printing.  Then during printing, expand WildcardedSigRefs (still not that clean, but better).
		createLogicalStructure();
		
		System.out.println("");
		
		//processes the behavioral structure and produces node declaration, flops and latches
		topBehHier.findNonLocalAssignments();
		topBehHier.fixWildcardedSv();
		topBehHier.createStagingRecursive();
		dumpSv();
		generateSv();
		//output clock declarations.
		generateSvClocks();
		
		doneStaging();
		
		if (!Main.command_line_options.bestSv())
		{
			printlnSVdeclaration("\ngenerate   // This is awkward, but we need to go into 'generate' context in the line that `includes the declarations file.");
		}
		
		//System.out.println("");
		//getLogicalPipeline("C1").printLogicalHierchy();
		//System.out.println("");

		//closes all generated files
		end();
	}
	
}
